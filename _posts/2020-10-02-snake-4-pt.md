---
layout: single
title:  "Desenvolvendo o jogo Snake [parte 4]"
toc: true
comments: true
categories: [game, snake]
tags: [python, pyxel]
---

Neste post vamos introduzir o conceito de colisão, tratando da comida para a cobra.

## Criando o alimento para a cobra

No jogo Snake o alimento que a cobra come é o que fará com que ela cresça de tamanho, tornando o jogo, com o tempo, mais desafiador. O algoritmo para criar o alimento para a cobra é muito simples, precisamos apenas sortear valores aleatórios para o `x` e `y` do alimento a ser posicionado na tela. Ele será sorteado sempre que o jogador realizar a captura do alimento. Vamos tentar criar essa função para o nosso jogo.

```python
import random

def nova_comida(self):
    comida = Posicao(
        random.randrange(self.tamanho_sprite, pyxel.width - self.tamanho_sprite, self.tamanho_sprite),
        random.randrange(self.tamanho_sprite, pyxel.height - self.tamanho_sprite, self.tamanho_sprite))

    # se a posicao sorteada para comida for uma posicao ocupada por um
    # segmento da cobra, tentar novamente ate conseguir um fora da cobra
    while comida in self.segmentos:
        comida = Posicao(
            random.randrange(self.tamanho_sprite, pyxel.width - self.tamanho_sprite, self.tamanho_sprite),
            random.randrange(self.tamanho_sprite, pyxel.height - self.tamanho_sprite, self.tamanho_sprite))
    return comida
```

Uma coisa importante para notar é que se não impusermos nenhuma restrição, a função que faz o sorteio da posição da cobra pode sortear uma posição que já é ocupada pela cobra. A estratégia aqui é continuar sorteando até que consigamos uma posição diferente das que a cobra já ocupa. Essa estratégia não é a melhor possível, porque à medida que a cobra for crescendo vai ficar cada vez mais difícil sortear uma posição que não seja ocupada pela cobra, uma vez que com o tempo ela vai ocupar cada vez mais posições na tela. Como esta série de posts é para iniciantes em programação não vamos nos preocupar com isso agora porque a solução ideal é mais complicada que esta que apresento aqui. É até um bom exercício para você tentar resolver esse problema sozinho :wink:

Pra finalizar as modificações relacionadas à criação de alimento, precisaos incluir uma linha nova no método `__init__` para criar um novo alimento assim que o jogo for inicializado (a modificação é apenas a inclusão da linha 11):
```python
def __init__(self):
    pyxel.init(208, 208)
    self.tamanho_sprite = 8
    self.segmentos = []
    cabeca = Posicao(pyxel.width/2, pyxel.height/2)
    self.segmentos.append(cabeca)
    self.segmentos.append(Posicao(pyxel.width/2 - self.tamanho_sprite, pyxel.height/2))
    self.segmentos.append(Posicao(pyxel.width/2 - self.tamanho_sprite*2, pyxel.height/2))
    self.segmentos.append(Posicao(pyxel.width/2 - self.tamanho_sprite*3, pyxel.height/2))
    self.direcao = DIREITA
    self.comida = self.nova_comida()
    pyxel.run(self.update, self.draw)
```
Perceba que também agora criamos a cobra com apenas 3 segmentos ao invés dos 5 que tínhamos antes (linhas 7-9).
### Implementando o método __eq__

Para que o teste `comida in self.segmentos` funcione, precisamos implementar um novo método na nossa classe `Posicao`, para que o Python consiga fazer a comparação da posição da comida com a posição de um segmento. Por padrão o operador `in` consegue testar, a partir do valor, tipos primitivos (como o `int`, por exemplo) e se os objetos são os mesmos. Se tivermos objetos diferentes, mesmo com os mesmos valores internos (no nosso caso `x` e `y`), o Python não vai dizer que eles são iguais, a não ser que digamos a ele como isso deve ser feito. Para isso, precisamos implementar o método `__eq__`, que vai permitir que o Python compare dois objetos diferentes para saber se são iguais semanticamente (baseado em seu conteúdo). Fica assim:

```python
class Posicao:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, outro):
        return self.x == outro.x and self.y == outro.y
```

## Passar por cima do próprio corpo não é permitido

Como você deve ter percebido, ainda não detectamos a condição clássica pra fim de jogo, que é a cobra passar por cima do próprio corpo. Para fazer isso precisamos fazer um teste bem simples. Lembra-se da nossa estratégia para fazer a cobra "parecer" que andava? Sempre criamos uma nova cabeça e removemos um segmento da cauda. Precisamos apenas verificar se essa nova cabeça, ao tentar ser inserida, ocuparia uma posição que já é ocupada por um outro segmento da cobra.
